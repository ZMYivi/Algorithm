## 162.寻找峰值

题目难度：中等

【题目描述】

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

【解题思路】

题目要求的是logn的复杂度，首先排除遍历。然后logn的算法首先想到的就是二分大法，观察题目中给的数据，是一个不会出现相邻相等元素相等的数组，再加上题目要求的是给出任意一个峰值，所以就可以通过二分来确定某一个峰值。

首先要确定找最大峰值还是最小峰值，我这里找的是最大的峰值，所以首先判断下当前的mid处于一个什么位置，是下降位置还是上升位置，如果是下降位，说明大峰值在左边，如果是上升位，则大峰值在右边。关于如果前后指针处于一个距离很远的位置，且中间隔了很多个大峰值，这种方法也是没问题的，因为题目保证了相邻元素不相等，即不会出现不知道当前处于什么位置的情况，还有就是题目要求任意输出一个峰值即可，所以保证了算法的可行性。

## 212.单词搜索 II

题目难度：困难

【题目描述】

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

【解题思路】

个人版本：无脑搜索，加点儿剪枝优化即可，首先题目要求字母不可以重复使用，所以可以加一个位置的判断，如果重复就返回，再根据题目中说的每个单词的长度不超过12，所以再加一个搜索的深度，就可以搞定了，感觉算法很合理，但是如果单词的长度变得更长一些则可能不会ac，下面附上个人版的代码

```c++
class Solution {
public:
    map<string, bool> flag;
    bool judge[14][14];
    int m, n, top;
    vector<string> findWords(vector<vector<char> >& board, vector<string>& words) {
        m = board.size(), n = board[0].size();
        top = 0;
        for(int i=0; i<words.size(); i++){
            if (words[i].size() > top) top = words[i].size();
        }
        for(int i=0; i<m; i++) {
            for(int j=0; j<n; j++) {
                memset(judge, 0, sizeof(judge));
                dfs(i, j, board, "", 0);
            }
        }
        vector<string> ans;
        for(int i=0; i<words.size(); i++) {
            if (flag[words[i]]) {
                ans.push_back(words[i]);
            }
        }
        return ans;
    }
    void dfs(int i, int j, vector<vector<char> >& board, string str, int deep) {
        if (deep >= top) return;
        if ((i<0)||(i>=m)||(j<0)||(j>=n)) return;
        if (judge[i][j]) return;
        flag[str + board[i][j]] = true;
        judge[i][j] = true;
        dfs(i+1, j, board, str + board[i][j], deep + 1);
        dfs(i-1, j, board, str + board[i][j], deep + 1);
        dfs(i, j+1, board, str + board[i][j], deep + 1);
        dfs(i, j-1, board, str + board[i][j], deep + 1);
        judge[i][j] = false;
        return;
    }
};
```

官方版本：官方给出的正确的答案是字典树加dfs，跟我的区别就是，我的方法是暴力搜索加剪枝，官方答案引导搜索，我的理解是这里的字典树起到的左右就是引导下个搜索的方向，但是这个方法确实很巧妙，之前听说过字典树，但是没有使用，这次使用了一把，确实好使，以后有类似的字符串的搜索，可以用一用，同时字典树也有一个小优化，就是每当匹配到一个单词之后就给删掉，对于那种全是一个字符的case有奇效。

## 384.打乱数组

题目描述：中等

【题目描述】

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:

Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果

【解题思路】

感觉这个题目有点儿无聊，不知为啥是中等题，就是一个简单的打乱数组的题目，随机的要求是每个位置的随机的概率是相同的，看了题解之后发现了一个有意思的算法名称：Fisher-Yates 洗牌算法

考虑通过调整waiting的实现方式以优化方法一。

我们可以在移除waiting的第k个元素时，将第k个元素与数组的最后1个元素交换，然后移除交换后数组的最后1个元素，这样我们只需要O(1)的时间复杂度即可完成移除第k个元素的操作。此时，被移除的交换后数组的最后1个元素即为我们根据随机下标获取的元素。

在此基础上，我们也可以不移除最后1个元素，而直接将其作为乱序后的结果，并更新待乱序数组的长度，从而实现数组的原地乱序。因为我们不再需要从数组中移除元素，所以也可以将第k个元素与第1个元素交换。

具体地，实现算法如下：

设待原地乱序的数组nums。
循环n次，在第i次循环中（0 \le i < n0≤i<n）：
在 [i,n)[i,n) 中随机抽取一个下标 jj；
将第 ii 个元素与第 jj 个元素交换。
其中数组中的 \textit{nums}[i \ .. \ n-1]nums[i .. n−1] 的部分为待乱序的数组，其长度为 n-in−i；\textit{nums}[0 \ .. \ i-1]nums[0 .. i−1] 的部分为乱序后的数组，其长度为 ii。

## 397.整数替换

题目难度：中等

【题目描述】

给定一个正整数 n ，你可以做如下操作：

1. 如果 n 是偶数，则用 n / 2替换 n 。
2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。

n 变为 1 所需的最小替换次数是多少？

【解题思路】

这个题目还挺有意思的，当数字是偶数的时候直接除2，当数字是奇数的时候加或减1，然后重复下去，看完题目直接无脑每次减1，但是直接被卡case，就是当数字加1为2的幂的形式，那么则可能会加一更优，所以就想出了使用dfs的方式，当是偶数时直接除2，当时奇数时，比较下那个次数更低，这里有个问题就是，因为题目给的数据范围是2^31-1，如果加一的话可能会导致直接报错，因此我们通过向下取整的方式来实现，例如，(n-1)/2变为n/2，(n+1)/2变为n/2+1。

这个方法给出的解题思路还是很有意思的，因为这个是一个递归的算法，时间复杂度可以通过每个元素被遍历的次数来确定，首先在递归的层上有个特点，<u>每层的最大值和最小值相差不超过1，</u>这是因为每层向下传递的时候都是同时除2，或者加上1，而这种性质就保证了这写出现的值符合斐波那契数列，也可以通过数学归纳法来证明。

证明方式和复杂度计算参考：https://leetcode-cn.com/problems/integer-replacement/solution/zheng-shu-ti-huan-by-leetcode-solution-swef/

## 430.扁平化多级双向链表

题目难度：中等

【题目描述】

多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。

【解题思路】

纯纯的模拟题，把题读完然后就可以写出来了，就是按照题目要求输出就完事了，一个简简单单的dfs，想吐槽下leetcode的中等题最近越来越水了。

2021.09.24

## 438.找到字符串中所有字母异位词

题目难度：中等

【题目描述】

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

【解题思路】

官方题解中给的这个题的方法是滑动窗口，我发现我自己总是把滑动窗口的题目做成前缀和的方法，这个题目也是，我直接统计前n想中26六个英文字母的数量和。滑动窗口的话就是统计单词的数量，看看滑动到当前有没有单词数量不为0的，这里他是用了两个字符串中的字母进行统计，p有某个字母就加一，s有某个字母就减一，这样的话如果属于异位词就会等于0。

## 485.可怜的小猪

题目难度：困难

【题目描述】

有 buckets 桶液体，其中 正好 有一桶含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 minutesToTest 分钟时间来确定哪桶液体是有毒的。

喂猪的规则如下：

1. 选择若干活猪进行喂养
2. 可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。
3. 小猪喝完水后，必须有 minutesToDie 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。
4. 过了 minutesToDie 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。
5. 重复这一过程，直到时间用完。

给你桶的数目 buckets ，minutesToDie 和 minutesToTest ，返回在规定时间内判断哪个桶有毒所需的 最小 猪数。

【解题思路】

这个题目有点儿意思，看第一眼就发现这个题目应该做过，就按照印象中的做法，就是把数字变换成2进制，然后按照轮数进行数组的组合。意思就是如果是四轮和三轮，那么就两位二进制数字组合在一起，如果是二轮或者一轮，那么就是一位二进制。交了之后发现不对，最后思来想去还是看了题解。

官方题解给的是dp，太复杂了直接没看，然后看了别的题解，恍然大悟，不一定非得搞成二进制，可以搞成n进制，这样就不会浪费某一轮的尝试，但是有一种情况要特殊处理，就是如果如果数字是n的幂，那么就要去掉最前面那一位，因为，后面的所有组合尝试完成之后，剩下的最后就是这个数字。

## 495.提莫攻击

题目难度：简单

【题目描述】

在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。

当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。

正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。

给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。

返回艾希处于中毒状态的 总 秒数。

【解题思路】

突然发现好久没刷题了，今天是个简单题，就是计算线段覆盖的总长度，只不过是一维，而且每个线段的长度都是一样的，这样就可以遍历所有的左边的点，然后判断下当前的点和上一个左点的距离，如果小于线段长度就加上这俩点的距离，如果大于就加上线段的长度。

2021.11.10

## 519.随机矩阵反转

题目难度：中等

【题目描述】

给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 Solution 类：

Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象
int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1
void reset() 将矩阵中所有的值重置为 0

【解题思路】

又是这种类型的题目，之前做过一个一维的，感觉这次的也没啥东西，唯一学到的一个东西就是map的种类，普通的map是一个红黑树维护的，这个是有序的map，unorder_map是一个无序的map，是一个哈希。因此可以了解到，无序的map可以更好的进行查询的操作，缺点是map的建立比较费时间，而有序的map查询需要费时，但是建立map的是不费时间。题解的话，维护一个映射，这个映射的内容就是下标。

## 650.只有两个键的键盘

题目难度：中等

【题目描述】

最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：

1. Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
2. Paste（粘贴）：粘贴 上一次 复制的字符。

给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

【解题思路】

个人版本：我是用的dp，比较好想一些，首先要明确下复制只能复制当前所有的字符，不允许复制部分，那么给出状态转移方程f[i]=max(f[i], f[j]+(i-j)/j+1)，当前i个字符可以由之前的0~i-1转移过来，所以对于f[j]来说，要转到到f[i]的前提是，可以被j整除，后面的加一是因为还需要一个复制的操作，下面给出代码。

```c++
class Solution {
public:
    int minSteps(int n) {
        int f[1002];
        memset(f, 0x3f, sizeof(f));
        f[1] = 0;
        f[2] = 2;
        for(int i=3; i<=n; ++i){
            for(int j=1; j<i; ++j) {
                int temp = INT_MAX;
                if((i - j) % j == 0) temp = f[j] + (i - j) / j + 1;
                if(f[i] > temp) f[i] = temp; 
            }
        }
        return f[n];
    }
};
```

官方版本：可气啊，总是有个比我更优的算法！官方给出的是分解质因数，是因为你需要到这来看这个问题，整个看是从1开始往上面组合，但是倒着看的话就是从n往下来组合，根据转移方程f[i]=max(f[j]+i/j)可以推出来f[i]=(f[i/j]+j)，也就是说我可以从i的任何一个大于1的因数k，花费k的代价就可以把它缩小一些，如果是没有因数的话，即为素数，那么该数字就只能由1组合出来，所以如果对于任何一个合数，可以分解成和若干素数乘积的形式，即ai的形式，那么将这些所有的ai加起来的代价肯定要比相乘（由1推演过来）要小，这个是可以给出数学证明的，当a1,a2都大于1，那么a1xa2-(a1+a2)=(a1-1)x(a2-1)-1>=0，因此，把数字n拆成质因数相加就可以得到解。

## 637.最长递增子序列的个数

题目难度：中等

【题目描述】

给定一个未排序的整数数组，找到最长递增子序列的个数。

【解题思路】

就是一个简单的递增序列，只不过需要额外维护一个当前位置的组成最长的方案个数，就完事了。

## 725.分隔链表

题目难度：中等

【题目描述】

给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

【解题思路】

这个题目，就是考察的对于链表的理解而已，没有涉及什么复杂的算法，就是注意在插入一个新的指针的时候，要处理最后的空指针，其他的就没有了，很水的中等题。
